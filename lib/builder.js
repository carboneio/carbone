var util = require('util');

var builder = {

  /**
   * Creates a string of the formatter(s) function(s) call of the attribute
   * INTERNAL USE ONLY
   * 
   * @param  {String} attr. Example 'd.number'
   * @param  {Array} formatters. Example [ 'int', 'toFixed(2)' ]
   * @return {String}. Example 'toFixed(int(d.number), 2)'
   */
  getFormatterString : function(attr, formatters){
    var _str = attr;
    for (var i = 0; i < formatters.length; i++) {
      var _splitFormatter = formatters[i].replace(/\)/g, '').split('(');
      var _arguments = _splitFormatter.slice(1).filter(function(item){
        return item.replace(/ +/g, '') !== '';
      });
      if(_arguments.length > 0){
        _arguments = _arguments.toString()
                      .replace(/^ +/g, '')
                      .replace(/ +$/g, '')
                      .replace(/ *, */g, '\', \'');
        _arguments = ', \'' + _arguments + '\'';
      }
      _str = 'formatters.' + _splitFormatter[0] + '(' + _str + _arguments + ')';
    }
    return _str;
  },

  /**
   * Assemble all xml parts and return the final result, the xml string with data
   *
   * @param {array} arrayOfStringPart :  special array which is generated by the function returned by getBuilderFunction
   * @param {integer} sortDepth : description
   * @return {string} final result
   */
  assembleXmlParts : function(arrayOfStringPart, sortDepth){
    var _res = '';
    this.sortXmlParts(arrayOfStringPart, sortDepth);
    for (var i = 0; i < arrayOfStringPart.length; i++) {
      _res += arrayOfStringPart[i].str;
    }
    return _res;
  },

  /**
   * Sort the special array which is generated by the function returned by getBuilderFunction.
   * INTERNAL USE ONLY (USED ONLY BY assembleXmlParts)
   *
   * @param {array} arrayToSort : array of objects
   * @param {integer} sortDepth 
   */
  sortXmlParts : function(arrayToSort, sortDepth){
    if(sortDepth === undefined){
      sortDepth = 1;
    }
    arrayToSort.sort(function(a, b){
      var i = 0;
      var _a = a.pos[i];
      var _b = b.pos[i];
      while(_a === _b && !(_a === undefined && _b === undefined) && i < sortDepth){
        i++;
        _a = a.pos[i];
        _b = b.pos[i];
      }
      if(_a === undefined){
        return -1;
      }
      else if(_b === undefined){
        return 1;
      }
      else{
        return (_a > _b) ? 1 : -1;
      }
    });
  },

  /**
   * Generate a function which will return an array of strings. 
   * This array of strings will be sorted and assemble by assembleXmlParts to get final result.
   *
   * @param {object} descriptor : data descriptor computed by the analyzer
   * @return {function} f
   */
  getBuilderFunction : function(descriptor){
    var that = this;
    var _str = "var _strResult = '';\n";
    _str += "var d = (data !== null)?data:{};\n";
    _str += "var _strPart = {};\n";
    _str += "var _strParts = [];\n";
    _str += "var _xmlPos = [0];\n";
    //_str += "var _nestedArrayParams = [];\n";
    var _lastArrayEnd = 0;
    var _nestedArray = [];
    var _keepHighestPosition = 0;
    var _nbCustomIterator = 0;

    var _dynamicData = descriptor.dynamicData || {};
    var _staticData = descriptor.staticData || {};
    var _hierarchy = descriptor.hierarchy || [];

    if(_staticData.before !== ''){
      _str += "_strPart = {\n";
      _str += "  'pos' : [0],\n";
      _str += "  'str' : '"+_staticData.before + "'\n";
      _str += "};\n";
      _str += "_strParts.push(_strPart);\n";
    }

    //declare all variables
    for(var _objName in _dynamicData){
      //the root "d" object is already declared above 
      if(_objName !== 'd' ){
        _str+= "var "+_objName+" = {};\n";
      }
    }

    //For each object, generate the code
    for (var _objIndex = 0; _objIndex < _hierarchy.length; _objIndex++) {
      var _objName = _hierarchy[_objIndex];
      var _realObjName = _dynamicData[_objName].name;
      var _type = _dynamicData[_objName].type;
      var _objParentName = _dynamicData[_objName].parent;
      var _xmlParts = _dynamicData[_objName].xmlParts;
      var _arrayDepth = _dynamicData[_objName].depth || 0;
      var _beforeStr = _dynamicData[_objName].before;

      //close previously created for-loops
      if( (_dynamicData[_objName].position && _lastArrayEnd <= _dynamicData[_objName].position.start) || _arrayDepth === 0 ){
        while(_nestedArray.length > 0){
          _str += "}\n";
          var _arrayNameLeft = _nestedArray.pop();
          if(_dynamicData[_arrayNameLeft].iterator !== undefined){
            _nbCustomIterator--;
          }
        }
      }

      //Object type
      if(_type === 'object'){
        //declare any nested object
        if(_objName!=='d'){
          _str += _objName+"="+ _objParentName+"['"+_realObjName+"'];\n";
        }
      }
      //Array type
      else if(_type === 'array'){
        var _posStart = _dynamicData[_objName].position.start;
        var _posEnd = _dynamicData[_objName].position.end;
        var _arrayIndexName = _objName+"_i";
        var _arrayName = _objName+"_array";
        var _iterator = _dynamicData[_objName].iterator;

        _str += "_xmlPos["+(_nbCustomIterator+_arrayDepth*2-2)+"] = "+_posStart+";\n";
        _str += "_xmlPos["+(_nbCustomIterator+_arrayDepth*2-1)+"] = "+_posStart+";\n";

        //declare any nested object
        if(_objName!=='d'){
          _str += "var "+_arrayName+"="+ _objParentName+"['"+_realObjName+"'];\n";
        }
        else{
          _str += "var "+_arrayName+"="+ _objName+";\n";
        }
        //keep the end of the array
        _lastArrayEnd = (_posEnd>_lastArrayEnd)? _posEnd : _lastArrayEnd;

        //add xml which are before the array repetition section
        if(_beforeStr !== undefined && _beforeStr !== ''){
          _str += "_strPart = {\n";
          _str += "  'pos' :  _xmlPos.slice(0, "+(_nbCustomIterator+_arrayDepth*2-1)+"),\n";
          _str += "  'str' : '"+_beforeStr + "'\n";
          _str += "};\n";
          _str += "_strParts.push(_strPart);\n";
        }
        //store array name 
        _nestedArray.push(_objName);
        _str += "var "+_arrayName+"_length = ("+_arrayName+" instanceof Array)?"+_arrayName+".length : 0;\n";
        _str += "for (var "+_arrayIndexName+" = 0; "+_arrayIndexName+" < "+_arrayName+"_length; "+_arrayIndexName+"++) {\n";
        _str += "  var "+_objName+" = "+_arrayName+"["+_arrayIndexName+"];\n";
        
        //use a custom iterator?
        if(_iterator !== undefined){
          var _iteratorName = _objName+"_it";
          var _iteratorObjName = _objName+"_itObj";
          _str += " var "+_iteratorName+" = 0;\n"; //TODO return errors if the iterator is not defined
          //the iterator is inside an object
          if(_iterator.obj !== undefined){
            _str += " var "+_iteratorObjName+" = "+_objName+"['"+_iterator.obj+"'];\n";
            _str += " if("+_iteratorObjName+" !== undefined) {\n";
            _str += "   "+_iteratorName+" = "+_iteratorObjName+"['"+_iterator.attr+"'];\n";
            _str += " }\n";
          }
          else{
            _str += " "+_iteratorName+" = "+_objName+"['"+_iterator.attr+"'];\n";
          }
          _str += "  _xmlPos["+(_nbCustomIterator+_arrayDepth*2-1)+"] = "+_iteratorName+";\n";
          //count the number of custom iterator
          _nbCustomIterator++;
          _str += "  _xmlPos["+(_nbCustomIterator+_arrayDepth*2-1)+"] = "+_arrayIndexName+";\n";
        }
        else{
          _str += "  _xmlPos["+(_nbCustomIterator+_arrayDepth*2-1)+"] = "+_arrayIndexName+";\n";
        }
      }
      //Generate code which will concatenate each xml parts
      for (var i = 0; i < _xmlParts.length; i++) {
        var _xmlPart = _xmlParts[i];
        var _dataObj = _xmlPart.obj;
        var _dataAttr = _xmlPart.attr;
        var _partDepth = _xmlPart.depth;
        var _formatters = _xmlPart.formatters || [];

        //keep highest position for the last xml part
        if(_xmlPart.pos > _keepHighestPosition){
          _keepHighestPosition = _xmlPart.pos;
        }
        //create the xml part and set its absolute position in the xml
        _str += "_xmlPos["+(_nbCustomIterator+_partDepth*2)+"] = "+_xmlPart.pos+";\n";
        _str += "_strPart = {\n";
        _str += "  'pos' : _xmlPos.slice(0, "+(_nbCustomIterator+_partDepth*2+1)+"),\n";
        _str += "  'str'    : ''\n";
        _str += "};\n";
        if(_xmlPart.before){
          _str += "_strPart.str = '"+_xmlPart.before + "';\n";
        }
        //insert the data only if it not null
        if(_dataAttr){
          var _field = that.getFormatterString(_dataObj + "['" + _dataAttr + "']", _formatters);
          _str += "if("+ _dataObj +" !== undefined){\n";
          _str += "var _str = " + _field + ";\n";
          //replace null or undefined value by an empty string
          _str += "if(_str === null && _str === undefined) {;\n";
          _str += "  _str = '';\n";
          _str += "};\n";
          //escape special characters for xml if the data is a string
          _str += "if(typeof(_str) === 'string') {;\n";
          _str += "  _str = _str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n";
          _str += "};\n";
          _str += "_strPart.str += (_str !== null && _str !== undefined)?_str:''"+";\n";
          _str += "}\n";
        }
        if(_xmlPart.after){
          _str += "_strPart.str += '"+_xmlPart.after + "';\n";
        }
        //push the xml part in a array (this array will be sorted at the end)
        _str += "_strParts.push(_strPart);\n";
      }
    }
    //close previously created for-loops
    while(_nestedArray.length > 0){
      _str += "}\n";
      _nestedArray.pop();
    }
    if(_staticData.after !== ''){
      _str += "_strPart = {\n";
      _str += "  'pos' : ["+(_keepHighestPosition+1)+"],\n";
      _str += "  'str' : '"+_staticData.after + "'\n";
      _str += "};\n";
      _str += "_strParts.push(_strPart);\n";
    }
    _str += 'return _strParts;';
    //console.log(_str);
    //The function is built, we compile it and check errors in the same time
    var _fn;
    try{
      _fn = new Function('data', 'formatters', _str);
    }
    catch (err){
      throw new Error('getSubstitutionFunction: Impossible to generate the XML builder.\n'+err+'\n--------------------------------\n'+_str+'\n--------------------------------\n');
    }
    return _fn;
  }

};

module.exports = builder;